module Endoscope where

import Data.Graph
import qualified Data.Graph as Graph

import Data.Set (Set)
import qualified Data.Set as Set

import qualified Data.Vector as Vector

import qualified Data.List as List

import MatMul
import Control.Monad
type Leaves = Integer
type Treelike = Bool

powset = Control.Monad.filterM (const [True, False])

transMult a b =  Vector.toList $Vector.backpermute (Vector.fromList a) (Vector.fromList b)
trans x = replicateM (length x) x
perm x =  List.permutations [0..x-1]

--endomult :: e -> e -> e
--endomult = undefined

--unrank :: Int -> e
--unrank = undefined

--enum :: Int -> Int
-- enum = undefined

--unranks :: Int -> String
--unranks = undefined

-- getIdempotents :: FunSet -> [a]

-- getTreelikes :: Set (a,a) -> [a] -- Have index >= 1
-- getLeaves :: Set (a,a) -> [a] -- nobody as a power goes to one of these guys
-- getGroupLikes :: Set (a,a) -> [a]  --- Have index == 0
-- Type Index = Integer
-- Type Period = Integer

-- classify :: a -> (Index, Period)


-- getLolipopHistogram :: FunSet -> [ (IntCount,IntInex, IntPeriod)]

-- getCompositionTable :: FunSet - > [ [IntFunID]] 


-- gadgets :: (a -> a) -> [[a]]
-- Returns the list of connected components in the function graph

-- ordNarrowGadgets :: (a -> a) -> [[a]]
-- Returns the list of connected components in the function graph in order of size where size < lg^{1/3} n

-- wideGadgets :: (a -> a) -> [[a]]
-- Returns the list of connected components in the function graph where size > lg^{1/3} n

-- toSuccinct :: (a -> a) -> SuccinctFunction



mono':: Ord a =>  (a -> a -> a) -> a -> Set (a,a)
mono' mult primal = mono mult (primal,primal) Set.empty


-- Usage: mono mult (primal,primal) Set.empty
-- Returns the set of elments generated by iterating primal
mono :: Ord a => (a -> a -> a) -> (a,a) -> Set (a,a) -> Set (a,a)
mono mult (primal, current) accum = if Set.member (primal,next) accum then accum else mono mult (primal, next) (Set.insert (primal,next) accum)
    where
      next = mult primal current



--Type Index = Integer
--Type Period = Integer

-- classify :: mult a -> (Index,Period, FirstCycle, Idempotent)
--classify :: (a -> a -> a) -> a -> (Index, Period, a , a )





-- Returns size elements of f iterated on seed
monogenic :: Int -> Int -> (Int -> Int -> Int) -> [Int]
monogenic size seed mult = take size $ iterate f seed
   where
      f = mult seed




-- endoscope :: generator -> endoFunc -> Set (a,a)
endoscope' :: Ord a => [a] -> (a -> a -> a) -> Set (a,a)
endoscope' elts mult = foldr (Set.union . mono' mult) Set.empty elts
--endoscope' elts mult = foldr Set.union Set.empty (map (mono' mult) elts )
--foldr :: (a -> b -> b) -> b -> [a] -> b
                    

endoscope :: Int -> (Int -> Int -> Int) -> Graph


endoscope size mult = buildG (0,size) $ concat [ g i | i <- [0..size]] 

  where 
      g blar =  zip (replicate size  blar) (f blar)  
        where
          f x = monogenic size x mult


type Row = [Bool]
type BoolMatrix = [Row]

multBM :: BoolMatrix -> BoolMatrix -> BoolMatrix
multBM a b = undefined



mul7 :: Int -> Int -> Int
mul7 x y = mod (x*y) 7

mulX :: Int -> Int -> Int -> Int
mulX m x y = mod (x*y) m

addX :: Int -> Int -> Int -> Int
addX m x y = mod (x+y) m


-- cycle through print mult x x == x

idempotents :: Ord a => [a] -> (a -> a -> a) -> [a]
idempotents elts mult = filter isSame elts 
       where
        isSame x = mult x x == x 


-- Examples:
-- Z2 Matrices | domain 2^{n*n}
-- Z3 matrices | domain 3^{n*n}
-- Life  | domain 2^{n*k}
-- EndoFactors | domain 2^{n+k}
--  Z_(k) +, * | domain n


-- Two concepts: Succinct representation of a single function, monogenic graph over a set of functions



--transMult :: [a] -> [a] -> [a]
--transMult x:xs ys = 

endoThing x = endoscope' [0..(x-1)] (mulX x)
--NEW IN OEIS?? Sum of orders of elements from the integers modulo n under multiplication
--map length $ map endoThing [1..50]

endoPermThing x =  endoscope' (perm x) transMult

endoTransThing x =  endoscope' (trans [0..(x-1)]) transMult

endoAddThing x = endoscope' [0..(x-1)] (addX x)
--A057660
--map length $ map endoAddThing [1..50]


endoMMThing x = endoscope' (matsZ2 x) mmult
idempMM x = idempotents (matsZ2 x) mmult

--map length $ map endoMMThing [1..4]
--[2,23,1297,275083] not found in OEIS

endoMAddThing x =  endoscope' (matsZ2 x) madd
--map length $ map endoMAddThing [1..4]
--[3,26,966,120836]


endoSetThing x = endoscope' (map Set.fromList $ powset [1..x]) Set.union
endoSetIntersectThing x = endoscope' (map Set.fromList $ powset [1..x]) Set.intersection
-- union mult op for all subsets of n
-- intersect mult op for all subsets of n
-- lexicographic max op for all subsets of n ?
-- symmetric difference mult op for all subsets of n ?
-- xor on boolean vectors of length n?


main = do print "Edges in monogenic inclusion graph of MatMul on Z2"
          print $ map length $ map endoMMThing [1..3]
          print "Edges in monogenic inclusion graph of co-MatMul on Z2"
          print $ map length $ map endoMAddThing [1..3]
          print "Edges in monogenic inclusion graph of multiply on Zn"
          print $ map length $ map endoThing [1..50]
          print "Edges in Tn"
          print $ map length $ map endoTransThing [1..6]
          print "Edges in Sn"
          print $ map length $ map endoPermThing [1..6]
          print "Edges in monogenic inclusion graph of add on Zn"
          print $ map length $ map endoAddThing [1..50]
          print "Edges in monogenic inclusion graph of Powerset under union"
          print $ map length $ map endoSetThing [1..5]    
          print "Edges in monogenic inclusion graph of Powerset under intersection"
          print $ map length $ map endoSetIntersectThing [1..5]
--mono :: Ord a => (a -> a -> a) -> (a,a) -> Set a -> Set a
--mono mult (primal,current) accum

   -- print $ components $ endoscope (3*3) mul7
    
