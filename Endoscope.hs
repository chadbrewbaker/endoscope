module Endoscope where

import Data.Graph
import qualified Data.Graph as Graph

import Data.Set (Set)
import qualified Data.Set as Set

import qualified Data.Vector as Vector

import qualified Data.Array as Array

import qualified Data.List as List

import qualified Data.Map as Map

import MatMul
import Control.Monad
type Leaves = Integer
type Treelike = Bool

powset = Control.Monad.filterM (const [True, False])

transMult a b =  Vector.toList $Vector.backpermute (Vector.fromList a) (Vector.fromList b)
trans x = replicateM (length x) x
perm x =  List.permutations [0..x-1]

--endomult :: e -> e -> e
--endomult = undefined

--unrank :: Int -> e
--unrank = undefined

--enum :: Int -> Int
-- enum = undefined

--unranks :: Int -> String
--unranks = undefined

-- getIdempotents :: FunSet -> [a]

-- getTreelikes :: Set (a,a) -> [a] -- Have index >= 1
-- getLeaves :: Set (a,a) -> [a] -- nobody as a power goes to one of these guys
-- getGroupLikes :: Set (a,a) -> [a]  --- Have index == 0
-- Type Index = Integer
-- Type Period = Integer

-- classify :: a -> (Index, Period)


-- getLolipopHistogram :: FunSet -> [ (IntCount,IntInex, IntPeriod)]

-- getCompositionTable :: FunSet - > [ [IntFunID]] 


-- gadgets :: (a -> a) -> [[a]]
-- Returns the list of connected components in the function graph

-- ordNarrowGadgets :: (a -> a) -> [[a]]
-- Returns the list of connected components in the function graph in order of size where size < lg^{1/3} n

-- wideGadgets :: (a -> a) -> [[a]]
-- Returns the list of connected components in the function graph where size > lg^{1/3} n

-- toSuccinct :: (a -> a) -> SuccinctFunction



-- Usage: mono mult (primal,primal) Set.empty
-- Returns the set of elments generated by iterating primal




--Type Index = Integer
--Type Period = Integer

-- classify :: mult a -> (Index,Period, FirstCycle, Idempotent)
--classify :: (a -> a -> a) -> a -> (Index, Period, a , a )



mono' :: Ord a => (a -> a -> a) -> (a,a) -> Set (a,a) -> Set (a,a)
mono' mult (primal, current) accum = if Set.member (primal,next) accum then accum else mono' mult (primal, next) (Set.insert (primal,next) accum)
    where
      next = mult primal current

mono :: Ord a =>  (a -> a -> a) -> a -> Set (a,a)
mono mult primal = mono' mult (primal,primal) Set.empty


-- endoscope :: generator -> endoFunc -> Set (a,a)
endoscope :: Ord a => [a] -> (a -> a -> a) -> Set (a,a)
endoscope elts mult = foldr (Set.union . mono mult) Set.empty elts
--endoscope' elts mult = foldr Set.union Set.empty (map (mono' mult) elts )
--foldr :: (a -> b -> b) -> b -> [a] -> b
                    
monoGraph :: Bounds -> Set Edge -> Graph
monoGraph b edges = Graph.buildG b $ Set.toList edges

leaves =  Graph.indegree 
-- Graph.indegree :: Graph -> Table Int


deTouple = map deTouple'
     where
      deTouple' a = [fst a, snd a]


--- Endofunctions where they are not a child of anyone else
-- (_,a)  matches [(a,a)] or []
-- (6,[]),(7,[7])
-- (a, []) = True
-- (a, [a] ) = True
-- _ false
--Array.elems
getLeaves elts mult =  filter isLeaf $ zip (Array.indices theInvertGraph) (Array.elems theInvertGraph)--thingIds
--getLeaves elts mult = Graph.indegree $ monoGraph bounds $ endoscope' elts mult
     where 
        -- bounds = (length elts, length elts)      
         thingIds = zip thing [0..(length thing)]
         thing = List.nub $ concat $ deTouple $ Set.toList $  endoscope elts mult
         thingToIDMap = Map.fromList thingIds
         mapPair (a,b) = ( (Map.!) thingToIDMap a, (Map.!) thingToIDMap b )
         forGraph = map mapPair  $ Set.toList $ endoscope elts mult
         
         theGraph = Graph.buildG (0, length thing - 1 ) forGraph
         theInvertGraph = Graph.transposeG theGraph
         isLeaf (i,[]) = True
         isLeaf (i, [x]) | i == x  = True
         isLeaf (_, _) = False

                      
         --filterLeaves :: (a, [a]) -> Bool
         --filterLeaves (a, b)
          --     | a [] = True
    -- 
      --         | a [a] = True
        --       | otherwise = False

    
         --invert (a,b) = (b,a)
        -- idToThingMap = Map.fromList $ map invert thingIds


--thing = List.nub $ concat $ deTouple $ Set.toList $ endoTransThing 3
--thingIds = zip thing [0..(length thing)]
--thingToIDMap = Map.fromList thingIds
--invert (a,b) = (b,a)
--idToThingMap = Map.fromList $ map invert thingIds





type Row = [Bool]
type BoolMatrix = [Row]

multBM :: BoolMatrix -> BoolMatrix -> BoolMatrix
multBM a b = undefined



mul7 :: Int -> Int -> Int
mul7 x y = mod (x*y) 7

mulX :: Int -> Int -> Int -> Int
mulX m x y = mod (x*y) m

addX :: Int -> Int -> Int -> Int
addX m x y = mod (x+y) m


-- cycle through print mult x x == x

idempotents :: Ord a => [a] -> (a -> a -> a) -> [a]
idempotents elts mult = filter isSame elts 
       where
        isSame x = mult x x == x 


-- Examples:
-- Z2 Matrices | domain 2^{n*n}
-- Z3 matrices | domain 3^{n*n}
-- Life  | domain 2^{n*k}
-- EndoFactors | domain 2^{n+k}
--  Z_(k) +, * | domain n


-- Two concepts: Succinct representation of a single function, monogenic graph over a set of functions



--transMult :: [a] -> [a] -> [a]
--transMult x:xs ys = 

endoThing x = endoscope [0..(x-1)] (mulX x)
idempThing x = idempotents [0..(x-1)] (mulX x)
leavesThing x = getLeaves [0..(x-1)] (mulX x)

--NEW IN OEIS?? Sum of orders of elements from the integers modulo n under multiplication
--map length $ map endoThing [1..50]

endoPermThing x =  endoscope (perm x) transMult
idempPermThing x = idempotents (perm x) transMult
leavesPermThing x = getLeaves (perm x) transMult

endoTransThing x =  endoscope (trans [0..(x-1)]) transMult
idempTransThing x = idempotents (trans [0..(x-1)]) transMult
transLeaves x = getLeaves (trans [0..(x-1)]) transMult

endoAddThing x = endoscope [0..(x-1)] (addX x)
idempAddThing x = idempotents [0..(x-1)] (addX x)
leavesAddThing x = getLeaves [0..(x-1)] (addX x)
--A057660
--map length $ map endoAddThing [1..50]


endoMMThing x = endoscope (matsZ2 x) mmult
idempMM x = idempotents (matsZ2 x) mmult
leavesMM x = getLeaves (matsZ2 x) mmult

--map length $ map endoMMThing [1..4]
--[2,23,1297,275083] not found in OEIS

endoMAddThing x =  endoscope (matsZ2 x) madd
idempMAddThing x = idempotents (matsZ2 x) madd
--map length $ map endoMAddThing [1..4]
--[3,26,966,120836]


endoSetThing x = endoscope (map Set.fromList $ powset [1..x]) Set.union
endoSetIntersectThing x = endoscope (map Set.fromList $ powset [1..x]) Set.intersection
-- union mult op for all subsets of n
-- intersect mult op for all subsets of n
-- lexicographic max op for all subsets of n ?
-- symmetric difference mult op for all subsets of n ?
-- xor on boolean vectors of length n?



--Run it for 2 * order, 2*order + 1 see who gets hit more than once, first top count is entrypoint item
--histogram of index, period
--Count of relunctant functions
--Count of reluctant function leaves
--Count of permutation like functions
--Min covering set, in parallel for each connected component
--Min dom detection set = sum of min dom set size for each connected component

-- All k tuples, does union of all k dom sets cover G


--pairToList :: [([a],[a])] -> [[a]]
--pairToList l = concat $ map deTuple l

--      where
--        deTuple x = concat((fst x) (snd x))

main = do print "Edges in monogenic inclusion graph of MatMul on Z2, new sequence"
          print $ map (length . endoMMThing) [1..3]
          print "Idempotents in BMM, OEIS A086907 and OEIS A132186"
          print $ map (length . idempMM) [1..3]
          print "Leaves in BMM, ??"
          print $ map (length . leavesMM) [1..4]


          print "Edges in monogenic inclusion graph of co-MatMul on Z2, new sequence"
          print $ map (length . endoMAddThing) [1..3]
          print "Idempotents in coBMM, need the sixth term to narrow down candidates"
          print $ map (length . idempMAddThing) [1..3] -- 1,4,10,22,46...
          print "Edges in monogenic inclusion graph of multiply on Zn, new sequence"
          print $ map (length . endoThing) [1..50]
          print "Idempotents in Zn under multiply, OEIS A034444"         
          print $ map (length . idempThing) [1..50]
          print "Leaves of Zn under multiply, new sequence"
          print $ map (length . leavesThing ) [1..50]

          print "Edges in Tn, new sequence"
          print $ map (length . endoTransThing) [1..6]
          print "Idempotents in Tn, OEIS A000248"
          print $ map (length . idempTransThing) [1..6]
          print "Leaves of Tn, new seqence"
          print $ map (length.transLeaves) [1..5] -- [1,3,15,138,1720,27180]

          print "Edges in Sn, OEIS A060014"
          print $ map (length . endoPermThing) [1..6]
          print "Idempotents in Sn, only the identity function"
          print $ map (length . idempPermThing) [1..6]
          print "Leaves in Sn, ???"
          print $ map (length . leavesPermThing) [1..6]

          print "Edges in monogenic inclusion graph of add on Zn, OEIS A057660"
          print $ map (length . endoAddThing) [1..50]
          print "Idempotents of add on Zn, just zero"
          print $ map (length . idempAddThing) [1..50]
          print "Leaves of add on Zn, ???"
          print $ map (length . idempAddThing) [1..50]
          --print "Edges in monogenic inclusion graph of Powerset under union"
          --print $ map length $ map endoSetThing [1..5]    
          --print "Edges in monogenic inclusion graph of Powerset under intersection"
          --print $ map length $ map endoSetIntersectThing [1..5]
--mono :: Ord a => (a -> a -> a) -> (a,a) -> Set a -> Set a
--mono mult (primal,current) accum

   -- print $ components $ endoscope (3*3) mul7
    
